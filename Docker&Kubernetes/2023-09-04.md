# 바인드 마운트 시작하기(코드 공유)

## why 바인드 마운트?

- 우리가 소스코드에서 무엇이든 변경할때 마다, 이미지를 다시 빌드하지않는 한 이러한 변경사항은 실행중인 컨테이너에 반영되지 않는다.

### 이유

- 우리는 도커 이미지가 생성 될 때 이들 폴더의 스냅샷만 복사한다. 따라서 해당 폴더의 모든 항목에 대한 미래의 변경 사항은 이미지에 반영되지 않으므로 컨테이너에도 반영되지 않는것이다.

### 문제점

- 개발중에 도커를 사용하면 변경 사항이 반영되는것은 우리에게는 매우 중요하다. 그렇지않으면 변경사항이 있을때마다 매번 전체 이미지를 리빌드하고 컨테이너를 다시 시작해야한다. 따라서 항상 모든것을 다시 시작하는것은 상당히 번거롭다. 그것을 바인드 마운트가 도와준다.

# 다시 바인드 마운트

- 바인드 마운트는 볼륨과 비슷한 점이 몇가지 있으나 한가지 중요한 차이점이 있다. 도커에 의해 관리되는 볼륨의 위치, 즉 호스트 머신의 파일 시스템 상의 볼륨이 어딨는지 우리는 실제로 알수없으나 바인드 마운트의 경우는 그 위치를 알고있다. 호스트 머신상에 매핑될 컨테이너의 경로를 설정하기때문이다. 그래서 로컬 호스트 머신상의 경로를 완전히 인식 할수있다. 그렇기때문에 컨테이너는 볼륨에 쓸 수 있을뿐만 아니라, 볼륨에서 읽을수도 있기에 당연히 소스 코드를 이러한 바인드 마운트에 넣을수있다. 이렇게 되면 컨테이너는 이를 인식해서 소스 코드를 실제로 스냅샷에서 복사하는 것이 아니라, 바인딩 마운트에서 복사한다. 그래서 컨테이너는 항상 최신 코드에 액세스 할 수 있다. 그리고 스냅샷뿐만 아니라 처음에 이미지를 생성할 때에 그 이미지에도 넣는다. **따라서 바인드 마운트는 영구적이고 편집 가능한 데이터 적합하다.** 명명된 볼륨은 영구데이터에는 도움되지만 편집은 실제로 불가능하다. 호스트 머신의 어디에 저장되어있는지 모르니까.

## 어떻게 바인드 마운트를 추가 할수 있을까?

- Dockerfile내부에서 할 수 있는것이 아니다. 실제로 이미지가 아니라 실행하는 컨테이너에만 적용되기때문에 이미지에는 영향을 주지않고, 컨테이너에만 영향을 준다. 그러므로 컨테이너를 실행할 때 터미널 내부에서 바인드 마운트를 설정해야한다.

```
data-volumes-01-starting-setup % docker run -d -p 3000:80 --rm --name feedback-app -v feedback:/app/feedback -v "/Users/admin/TIL/Docker&Kubernetes/data-volumes-01-starting-setup:/app" feedback-node:volumes
```

볼륨을 추가했던것처럼 -v를 붙혀준다. 그런데 중요한 차이점은 컨테이너 내부의 매핑하려는 폴더는 물론 /app 이다. 내 모든 소스코드를 여기 /app에만 복사하고있으니까. 이 app 폴더를 제어하려고 하기위해서는 콜론앞에 지정하는 이름이 이제 'app' 같은 것이아니라 호스트 머신상의 경로가 되어야한다. 모든코드, 모든 콘텐츠가 있는 그곳이 이 /app 폴더에 매핑된다. 그리고 이것은 **상대경로가 아닌 절대경로여야한다.** 프로젝트 폴더의 경로여야하며 단일 파일을 컨테이너와 공유하려는 경우 파일을 명시할수도있다. **절대경로와 콜론 그리고 매핑될 경로까지 큰따옴표로 묶을수도있다. 특수문자나 공백히 포함된 경우 깨지지안도록 하기위해**

# 바인드 마운트와 폴더를 컨테이너에 마운트하는것에 대한 중요 참고사항

- 바인딩 마운트로 공유 중인 폴더에 도커가 액세스 할 수 있는지 반드시 확인해야함.
  - 도커의 기본설정(Preferences)에 액세스하여 이를 수행할수있다. Resources-File sharing 아래에 지금 공유하고있는 폴더가 여기에 리스팅 되는지 확인해야한다. 공유중인 폴더의 상위 푤더가 표시되어야함.
    이렇게했음에도 불구하고 충돌이나며 종료된 컨테이너, 중지된 컨테이너에서 찾을 수 없다.
    --rm 을 빼고 실행한뒤 docker logs로 에러 로그를 살펴보자.
