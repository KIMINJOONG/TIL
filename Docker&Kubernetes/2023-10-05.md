# 다중 컨테이너로 작업하기

- backend를 해보자

  1. 이미지는 'goals-node'로 그러나 모든 이미지를 제거했으므로 더이상 존재하지않음. 리빌드할수있나, 도커 컴포즈는 빌드단계도 대체해준다. 완성된 이미지를 지정하는 대신 이미지를 빌드하는데 필요한 정보 제공 가능

     - 이미지가 속한 컨테이너 아래에 build옵션으로 수행

       1. Dockerfile을 찾을수있는곳을 상대 경로를 사용하여 표현

          - 경로를 따라가 Dockerfile을 읽는다 이것이 빌드되면 컨테이너에 해당 이미지를 사용함
          - 혹은 build안에 context를 사용하여 Dockerfile 경로 특정 dockerfile키 안에 Dockerfile 이라고 지정 그러나 이름이 Dockerfile-dev라면 이런식으로 커스텀된 파일을 지정한다.

       2. Dockerfile에서 ARG를 사용하면 경우 build아래에 args로 지정할수있다.

  2. goals-backend를 실행하기 위해서는 환경변수, 세개의 볼륨,자동제거, detached모드, 네트워크, 포트가 필요하다.
  3. backend아래에 ports추가(게시 포트 지정 목록으로 가능)

  - '-'를 사용하여 표현 예를들어, 호스트 포트가 3000에 컨테이너 내부가 80이라면

  ```
  ports:
    - '80:80'
  ```

  4. volumes 추가

  - 명명된 볼륨 추가(최상위 볼륨 키에 추가)
  - 바인드 마운트의 경우 docker run시에 절대경로가 필요했으나 도커 컴포즈는 상대 경로를 사용할수있다.(최상위 볼륨키 추가 x)
  - 익명 볼륨 추가(최상위 볼륨 키에 추가할수없으므로 제일 아래에 추가할 필요 x)

  5. env_file 추가
  6. depends_on 추가

  - docker run 에는 없는 도커 컴포즈에만 있는 명령 도커 컴포즈를 사용하면 여러 서비스를 만들고 시작 즉, 동시에 여러 컨테이너 생성 때로는 하나의 컨테이너가 이미 실행되고 있는 다른 컨테이너에 의존
  - backend는 실제로 이미 실행중인 mongodb에 의존. 그러므로 의존성을 표현해야함.
  - mongodb를 먼저 불러와야함을 컴포즈에게 알려줘야한다 그리고 그게 실행된 후 backend 컨테이너를 생성해야함

  ```
  depends_on:
    - mongodb
  ```

  - 대시로 여러개 추가 가능

  7. docker-compose up -d로 실행

- 컨테이너를 리스팅해보면 정의된 이름이 docker-complete_backend_1 이런식으로 나옵니다. services에서 mongodb라고 명명했는데도, 그러나 본래 이름은 도커에 의해 기억되기때문에 코드내에서 이름을 사용하여 네트워크 연결을 하는것에는 문제가 없다. 그래서 app.js에서 mongodb라는 이름에 연결해도 여전히 작동하는것이다.
